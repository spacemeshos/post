package main

import (
	"code.cloudfoundry.org/bytefmt"
	"encoding/hex"
	"flag"
	"fmt"
	"github.com/olekukonko/tablewriter"
	"github.com/spacemeshos/post/initialization"
	"github.com/spacemeshos/post/proving"
	"github.com/spacemeshos/post/shared"
	"github.com/spacemeshos/post/validation"
	"log"
	"os"
	"runtime"
	"strconv"
	"time"
)

type Config = shared.Config

var (
	id, _        = hex.DecodeString("deadbeef")
	challenge, _ = hex.DecodeString("this is a challenge")
	defConfig    = shared.DefaultConfig()
)

type benchMode int

const (
	single benchMode = 1 + iota
	mid
	full
)

var modes = []string{
	"single",
	"mid",
	"full",
}

func (m benchMode) isValid() bool { return m >= single && m <= full }

func (m benchMode) String() string { return modes[m-1] }

func main() {
	flag.StringVar(&defConfig.DataDir, "datadir", defConfig.DataDir, "filesystem datadir path")
	flag.Uint64Var(&defConfig.SpacePerUnit, "space", 1<<23, "space per unit, in bytes")
	mode := flag.Int("mode", int(mid), fmt.Sprintf("benchmark mode: %v=%d,%v=%d, %v=%d",
		single, single, mid, mid, full, full))
	flag.Uint64Var(&defConfig.FileSize, "filesize", 1<<23, "space per file, in bytes (in single mode only, otherwise it is autogenerated)")
	flag.UintVar(&defConfig.MaxFilesParallelism, "pfiles", defConfig.MaxFilesParallelism, "max degree of files parallelism (in single mode only, otherwise it is autogenerated)")
	flag.UintVar(&defConfig.MaxInFileParallelism, "pinfile", defConfig.MaxInFileParallelism, "max degree of cpu work parallelism per file (in single mode only, otherwise it is autogenerated)")

	flag.Parse()

	benchMode := benchMode(*mode)
	if !benchMode.isValid() {
		panic(fmt.Sprintf("invalid mode: %d", benchMode))
	}

	log.Printf("bench config: mode: %v, datadir: %v, space: %v",
		benchMode, defConfig.DataDir, bytefmt.ByteSize(defConfig.SpacePerUnit))

	cases := genTestCases(benchMode)
	results := make([][]string, 0)
	for i, cfg := range cases {
		log.Printf("test %v/%v starting...", i+1, len(cases))
		tStart := time.Now()

		init := initialization.NewInitializer(&cfg, shared.DisabledLogger{})
		prover := proving.NewProver(&cfg, shared.DisabledLogger{})
		validator := validation.NewValidator(&cfg)

		t := time.Now()
		proof, err := init.Initialize(id)
		if err != nil {
			panic(err)
		}
		eInit := time.Since(t)

		t = time.Now()
		err = validator.Validate(proof)
		if err != nil {
			panic(err)
		}
		eInitV := time.Since(t)

		t = time.Now()
		proof, err = prover.GenerateProof(id, challenge)
		if err != nil {
			panic(err)
		}
		eExec := time.Since(t)

		t = time.Now()
		err = validator.Validate(proof)
		if err != nil {
			panic(err)
		}
		eExecV := time.Since(t)

		err = init.Reset(id)
		if err != nil {
			panic(err)
		}

		log.Printf("test %v/%v completed, %v", i+1, len(cases), time.Since(tStart))

		pfiles, pinfile := init.CalcParallelism(runtime.NumCPU())
		numFiles, _ := shared.NumOfFiles(cfg.SpacePerUnit, cfg.FileSize)

		results = append(results, []string{
			strconv.Itoa(numFiles),
			strconv.Itoa(pfiles),
			strconv.Itoa(pinfile),
			eInit.Round(time.Duration(time.Millisecond)).String(),
			eInitV.Round(time.Duration(time.Microsecond)).String(),
			eExec.Round(time.Duration(time.Millisecond)).String(),
			eExecV.Round(time.Duration(time.Microsecond)).String(),
		})
	}

	resultsHeader := []string{"numfiles", "p-files", "p-infile", "init", "init-v", "exec", "exec-v"}
	report(resultsHeader, results)
}

func report(resultsHeader []string, results [][]string) {
	fmt.Printf("\n- Results -\n")
	fmt.Printf("DATADIR: %v\n", defConfig.DataDir)
	fmt.Printf("SPACE: %v\n", bytefmt.ByteSize(defConfig.SpacePerUnit))

	table := tablewriter.NewWriter(os.Stdout)
	table.SetHeader(resultsHeader)
	table.SetBorder(true)
	table.AppendBulk(results)
	table.Render()
}

func genTestCases(mode benchMode) []Config {
	cases := make([]Config, 0)
	if mode == single {
		cases = append(cases, *defConfig)
		return cases
	}

	def := *defConfig
	def.FileSize = defConfig.SpacePerUnit
	def.MaxFilesParallelism = 1
	def.MaxInFileParallelism = 1

	// Various in-file parallelism degrees.
	max := runtime.NumCPU()
	for i := 1; i <= max; i++ {
		cfg := def
		cfg.MaxInFileParallelism = uint(i)

		switch mode {
		case full:
			cases = append(cases, cfg)
		case mid:
			if i == 1 || i == max {
				cases = append(cases, cfg)
			}
		}
	}

	// Split to files without files parallelism.
	max = 6
	for i := 1; i <= max; i++ {
		cfg := def
		cfg.FileSize >>= uint(i)

		switch mode {
		case full:
			cases = append(cases, cfg)
		case mid:
			if i == 1 || i == max {
				cases = append(cases, cfg)
			}
		}
	}

	// Split to files with max files parallelism degrees.
	max = 6
	for i := 1; i <= max; i++ {
		cfg := def
		cfg.FileSize >>= uint(i)
		cfg.MaxFilesParallelism <<= uint(i)

		switch mode {
		case full:
			cases = append(cases, cfg)
		case mid:
			if i == 1 || i == max {
				cases = append(cases, cfg)
			}
		}
	}

	// Split to files with max files and in-file parallelism degrees.
	max = 4
	for i := 1; i <= max; i++ {
		cfg := def
		cfg.FileSize >>= uint(i)
		cfg.MaxFilesParallelism <<= uint(i)
		cfg.MaxInFileParallelism <<= uint(i)

		switch mode {
		case full:
			cases = append(cases, cfg)
		case mid:
			if i == 1 || i == 2 {
				cases = append(cases, cfg)
			}
		}
	}

	return cases
}
