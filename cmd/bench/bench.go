package main

import (
	"code.cloudfoundry.org/bytefmt"
	"encoding/csv"
	"encoding/hex"
	"flag"
	"fmt"
	"github.com/olekukonko/tablewriter"
	"github.com/shirou/gopsutil/cpu"
	"github.com/shirou/gopsutil/mem"
	"github.com/spacemeshos/post/config"
	"github.com/spacemeshos/post/initialization"
	"github.com/spacemeshos/post/proving"
	"github.com/spacemeshos/post/verifying"
	"io"
	"log"
	"os"
	"runtime"
	"runtime/pprof"
	"strconv"
	"strings"
	"time"
)

type Config = config.Config

var (
	id                = make([]byte, 32)
	challenge, _      = hex.DecodeString("this is a challenge")
	defConfig         = config.DefaultConfig()
	computeProviderID *uint
)

type benchMode int

const (
	single benchMode = 1 + iota
	mid
	full
)

var modes = []string{
	"single",
	"mid",
	"full",
}

func (m benchMode) isValid() bool { return m >= single && m <= full }

func (m benchMode) String() string { return modes[m-1] }

// TODO(moshababo): extend benchmarks to contain a variance of `ComputeBatchSize` values.
// the current benchmarks are of the old PoST version, and were merely fixed to be working
// and to have a variance of `computeProviderID` values. They should be improved once used again.
func main() {
	flag.StringVar(&defConfig.DataDir, "datadir", defConfig.DataDir, "filesystem datadir path")
	flag.Uint64Var(&defConfig.NumLabels, "numlabels", 1<<15, "number of labels")
	flag.UintVar(&defConfig.NumFiles, "numfiles", 1, "number of files (in single mode only, otherwise it is autogenerated)")
	computeProviderID = flag.Uint("provider", 0, "compute provider id (in single mode only, otherwise it is autogenerated)")
	mode := flag.Int("mode", int(mid), fmt.Sprintf("benchmark mode: %v=%d,%v=%d, %v=%d",
		single, single, mid, mid, full, full))

	disktype := flag.String("disktype", "", "specify the disk type (to be used in report)")
	fstype := flag.String("fstype", "", "specify the file-system type (to be used in report)")
	desc := flag.String("desc", "", "specify the test run description (to be used in report)")
	cpuprof := flag.String("cpuprof", "", "write cpu profile to file")
	memprof := flag.String("memprof", "", "write memory profile to file")
	report := flag.String("report", "report.csv", "write report csv to file")

	flag.Parse()

	if *cpuprof != "" {
		f, err := os.Create(*cpuprof)
		if err != nil {
			log.Fatal("could not create CPU profile: ", err)
		}
		defer f.Close()
		if err := pprof.StartCPUProfile(f); err != nil {
			log.Fatal("could not start CPU profile: ", err)
		}
		defer pprof.StopCPUProfile()
	}

	benchMode := benchMode(*mode)
	if !benchMode.isValid() {
		log.Fatalf("invalid mode: %d", benchMode)
	}

	log.Printf("bench config: mode: %v, datadir: %v, numLabels: %v",
		benchMode, defConfig.DataDir, defConfig.NumLabels)

	cases := genTestCases(benchMode)
	data := make([][]string, 0)
	for i, c := range cases {
		log.Printf("test %v/%v starting...", i+1, len(cases))
		tStart := time.Now()

		init, err := initialization.NewInitializer(&c.cfg, id)
		if err != nil {
			log.Fatal(err)
		}
		prover, err := proving.NewProver(&c.cfg, id)
		if err != nil {
			log.Fatal(err)
		}

		t := time.Now()
		err = init.Initialize(c.computeProviderID)
		if err != nil {
			log.Fatal(err)
		}
		eInit := time.Since(t)

		t = time.Now()
		proof, proofMetadata, err := prover.GenerateProof(challenge)
		if err != nil {
			log.Fatal(err)
		}
		eExec := time.Since(t)

		t = time.Now()
		err = verifying.Verify(proof, proofMetadata)
		if err != nil {
			log.Fatal(err)
		}
		eExecV := time.Since(t)

		err = init.Reset()
		if err != nil {
			log.Fatal(err)
		}

		log.Printf("test %v/%v completed, %v", i+1, len(cases), time.Since(tStart))

		data = append(data, []string{
			fmt.Sprintf("%d", c.computeProviderID),
			fmt.Sprintf("%d", c.cfg.NumFiles),
			eInit.Round(time.Duration(time.Millisecond)).String(),
			eExec.Round(time.Duration(time.Millisecond)).String(),
			eExecV.Round(time.Duration(time.Microsecond)).String(),
		})
	}

	header := []string{"PROVIDER", "NUMFILES", "INIT", "EXEC", "EXEC-V"}
	metadata := getMetadata(defConfig, *disktype, *fstype, *desc)

	exportTable(metadata, header, data, os.Stdout)
	exportCSV(metadata, header, data, *report)

	if *memprof != "" {
		f, err := os.Create(*memprof)
		if err != nil {
			log.Fatal("could not create memory profile: ", err)
		}
		defer f.Close()
		runtime.GC() // Get up-to-date statistics.
		if err := pprof.WriteHeapProfile(f); err != nil {
			log.Fatal("could not write memory profile: ", err)
		}
	}
}

func exportCSV(metadata []kv, header []string, data [][]string, path string) {
	file, err := os.Create(path)
	if err != nil {
		log.Panicf("report file creation failed: %v", err)
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	// Writing metadata.

	mdHeader := make([]string, len(metadata))
	mdData := make([]string, len(metadata))
	for i, item := range metadata {
		mdHeader[i] = item.k
		mdData[i] = item.v
	}

	if err := writer.WriteAll([][]string{mdHeader, mdData, {}}); err != nil {
		log.Panic(err)
	}

	// Writing data.

	if err := writer.Write(header); err != nil {
		log.Panic(err)
	}

	if err := writer.WriteAll(data); err != nil {
		log.Panic(err)
	}
}

func exportTable(metadata []kv, header []string, data [][]string, writer io.Writer) {
	fmt.Printf("\n- Results -\n")
	for _, item := range metadata {
		if item.k == "CPU_FLAGS" {
			continue
		}
		fmt.Printf("%v: %v\n", item.k, item.v)
	}

	table := tablewriter.NewWriter(writer)
	table.SetHeader(header)
	table.SetBorder(true)
	table.AppendBulk(data)
	table.Render()
}

type testCase struct {
	cfg               Config
	computeProviderID uint
}

func genTestCases(mode benchMode) []testCase {
	cases := make([]testCase, 0)
	if mode == single {
		c := testCase{*defConfig, *computeProviderID}
		cases = append(cases, c)
		return cases
	}

	def := *defConfig
	def.NumFiles = 1

	for _, p := range initialization.Providers() {
		c := testCase{def, p.ID}
		cases = append(cases, c)
	}

	return cases
}

type kv struct {
	k string
	v string
}

func getMetadata(cfg *Config, disktype string, fstype string, desc string) []kv {
	// Using slice of kv instead of a map to maintain order.
	m := make([]kv, 0)

	if desc != "" {
		m = append(m, kv{k: "DESC", v: desc})

	}

	m = append(m, kv{k: "DATADIR", v: cfg.DataDir})
	m = append(m, kv{k: "NUMLABELS", v: fmt.Sprintf("%d", cfg.NumLabels)})

	if disktype != "" {
		m = append(m, kv{k: "DISK", v: disktype})
	}

	if fstype != "" {
		m = append(m, kv{k: "FS", v: fstype})
	}

	m = append(m, kv{k: "OS", v: runtime.GOOS})

	cpuInfo, err := cpu.Info()
	if err != nil {
		log.Fatal(err)
	}
	m = append(m, kv{k: "CPU_MODEL", v: cpuInfo[0].ModelName})
	m = append(m, kv{k: "CPU_FLAGS", v: strings.Join(cpuInfo[0].Flags, " ")})
	m = append(m, kv{k: "CPU_CORES", v: strconv.Itoa(int(cpuInfo[0].Cores))})
	m = append(m, kv{k: "CPU_LOGICAL", v: strconv.Itoa(runtime.NumCPU())})

	memInfo, err := mem.VirtualMemory()
	if err != nil {
		log.Fatal(err)
	}
	m = append(m, kv{k: "MEM_FREE", v: bytefmt.ByteSize(memInfo.Free)})

	return m
}
